# THE MYTHICAL MAN-MONTH

## :ticket: Chapter 1. 진흙 구덩이
1. **프로그래밍 시스템 제품**
    * 프로그램 : 일명 "차고에서 만들어지는 것"
    * 프로그래밍 제품 : 프로그램 + 일반화, 테스트, 문서화, 유지보수 -> 프로그램의 3배 개발 비용
    * 프로그래밍 시스템 : 프로그램 + 인터페이스, 호환성 -> 프로그램의 3배 개발 비용
    * 프로그래밍 시스템 제품 : 프로그램 시스템 + 제품 -> 프로그램의 9배 개발 비용
2. **작업의 즐거움**
    * **창작**의 즐거움 : 무엇을 만든다는 순수한 즐거움
    * **유용성**의 즐거움 : 다른 사람에게 쓸모 있는 뭔가를 만드는 데서 오는 즐거움
    * **문제 해결**의 즐거움 : 복잡한 객체를 멋지게 만들어내고 그것이 절묘한 사이클로 작동하며, 개발 시작 시 정한 원칙이 어떤 결과를 낳았는지 지켜보는 즐거움
    * **학습**의 기쁨 : 항상 새로운 무언가를 배운다는 기쁨
    * **매체 이용**의 즐거움 : 다루기 쉬운 매체를 통해 창작에 대한 열망 충족
3. **작업의 고통**
    * **완벽성** 요구 : 문자 하나라도 올바른 형식에 맞지 않으면 작동 X
    * **권한** 부족 : 작업 환경, 목표 설정 등의 권한은 타인에 종속됨 / 타인의 불완전한 프로그램에 의존
    * **버그 수정** : 자잘한 버그 찾기 및 수정은 단순 노동에 불과 / 프로그램의 완성에 다가갈수록 더욱 느려지는 오류 검증
    * **퇴물화** : 겨우 완성한 제품의 아이디어가 쓸모없는 퇴물임이 드러남

## :ticket: Chapter 2. 맨먼스 미신
1. **낙관주의**
    * 모든 임무가 주어진 시간 안에 꼭 완수될 것이라는 잘못된 가정
    * 구현에서의 어려움은 물리적 매체의 한계와 아이디어의 현실 부적합성
    * 다만, 컴퓨터 프로그래밍은 다루기 쉬운 매체를 이용하므로 아이디어의 문제 -> 낙관주의를 정당화하기는 어려움
2. **Man-Month**
    * Man-Month : 견적과 일정에 사용되는 노력의 단위 / 다른 작업의 경우 작업자가 많을수록 일정은 줄어듦
    * 시스템 프로그래밍에서는 **상호 커뮤니케이션**과 **순차적 제한**이 존재하므로 작업자가 늘어도 일정은 그대로
    * 인력이 늘어날수록 **훈련** 및 **커뮤니케이션**의 부담이 기하급수적으로 증가 -> 일정이 오히려 연장되는 상황 초래
3. **시스템 테스트**
    * 저자의 일정 분배 방식 : 33% 계획 / 17% 코딩 / 25% 컴포넌트 및 초기 시스템 테스트 / 25% 시스템 테스트 및 모든 컴포넌트 입수
    * 상세하고 확실한 명세를 만들어내기에는 넉넉하지 않으므로 계획에 할애된 부분을 보통보다 늘림
    * 전체 일정의 **절반**을 **디버깅**에 할애
    * 예측하기 쉬운 코딩 작업은 가장 적게 할애
4. **비겁한 견적**
    * 정량적 방법론이 아닌 직감에 의한 견적은 위험함
    * 버그 발생 수치나 견적 규칙 등의 **생산성 수치**를 개발하고 발표한다면 도움이 됨
5. **되풀이되는 일정 참사**
    * 일정이 늦어진 소프트웨어 프로젝트에 인력을 추가하는 것은 일정을 더욱 늦추는 결과를 낳을 뿐이다.

## :ticket: Chapter 3. 수술 팀
1. **문제 상황**
    * **효율성과 개념적 무결성**을 원한다면 **소수 정예**의 팀으로 설계 및 개발
    * 대형 시스템의 경우 **충분한 인력**을 투입해 **적절한 시기에 제품을 출시**해야 함
    * 둘 사이의 딜레마를 어떻게 조화시켜야 하는가?
2. **밀스의 제안**
    * 대형 작업의 각 부분을 수술 팀처럼 나누어서 처리 (아래는 총 10명으로 구성된 팀의 역할 분배 예시)
    * **외과의사 (프로그래머 장)** : 상당한 수준의 지식 보유자 - 프로그램 설계 / 코드 작성 및 테스트 / 문서 작업
    * **부기장** : 외과의사의 보험과 같은 역할 - 프로그램 설계 시 같이 고민/토론 및 평가
    * **행정관** : 돈과 인력, 공간, 행정조직과의 접촉 등을 전담하는 사람
    * **편집자** : 외과의사가 만든 문서 초안을 비평 및 재작업
    * **비서** : 행정관과 편집자에게 각각 비서 1명 씩은 필요
    * **프로그램 사무원** : 프로그래밍-제품 라이브러리에 있는 팀의 모든 기술적 기록의 관리 책임
    * **도구 대장장이** : 자신 팀의 외과의사가 원하거나 필요한 도구를 확보
    * **검사원** : 시스템의 테스트 케이스 고안 / 디버깅 진행
    * **언어 변호사** : 특정 언어를 사용하는 참신하고 효과적인 방법 발굴
3. **운영 방식**
    * 외과의사와 부기장 모두가 전체 설계와 코드 전체를 모두 알고 있어 공간과 디스크 액세스 할당 등의 노력 절감 가능
    * 수술 팀 방식에서는 수평적보다는 수직적에 가까우므로 이해관계가 충돌할 염려가 적음
    * 구성원들 사이의 커뮤니케이션의 극단적인 단순화

## :ticket: Chapter 4. 귀족정치, 민주주의 그리고 시스템 설계
1. **개념적 무결성**
    * 시스템이 하나의 목표를 따르며, **일관된 설계**를 바탕으로 제작되는 것
    * 시스템 프로그래밍의 목적은 컴퓨터를 좀 더 **쉽게** 사용하려는 것 - **기능 vs 개념적 복잡함**의 비율은 시스템 설계 점검에 최적의 척도
    * 기능이 주어지면 그것을 가장 단순하고 직설적으로 명세할 수 있는 시스템이 최고
    * 사용의 쉬움 = 설계 및 개념의 무결성
2. **귀족정치와 민주주의**
    * 개념적 무결성 vs 일정 압박 - **시스템 설계 인원 수**의 딜레마 발생
    * 첫 번째 해결법 : 설계자와 실제 프로그래머들의 작업을 조심스럽게 **분할**
        * **설계**는 어떤 일이 일어나는지 설명 / **구현**은 그 일이 일어나게 하려면 어떻게 되어야 하는지 설명
        * Ex) 시계 설계는 문자판, 시침, 태엽 감개 등의 구조 / 시계 구현은 시계의 동력 공급이나 정확성 제어 등의 메커니즘에 대한 설명
        * 일부 설계자들만의 **귀족정치** vs 모두에게 아이디어를 모으는 **민주주의**
            * 설계의 경우 시스템의 개념적 무결성을 높이기 위해 전자를 선호
            * 구현의 경우 다양한 아이디어, 기술적 탁월성 등이 필요하므로 후자를 선호 
    * 두 번째 해결법 : 프로그래밍 구현 팀을 새롭게 구성
3. **구현자들은 기다리는 동안 무엇을 하나?**
    * 전체적인 작업은 아키텍처, 구현, 실현 세 가지 단계가 존재 - 모두 병렬적으로 진행 가능
    * 명확한 시스템 개요, 비용, 성능 목표 정도만 있어도 작업 시작 가능
    * 서브루틴 규칙, 감독 기법, 검색 및 정렬 알고리즘 결정
