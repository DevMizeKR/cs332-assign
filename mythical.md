# THE MYTHICAL MAN-MONTH

## :ticket: Chapter 1. 진흙 구덩이
1. **프로그래밍 시스템 제품**
    * 프로그램 : 일명 "차고에서 만들어지는 것"
    * 프로그래밍 제품 : 프로그램 + 일반화, 테스트, 문서화, 유지보수 -> 프로그램의 3배 개발 비용
    * 프로그래밍 시스템 : 프로그램 + 인터페이스, 호환성 -> 프로그램의 3배 개발 비용
    * 프로그래밍 시스템 제품 : 프로그램 시스템 + 제품 -> 프로그램의 9배 개발 비용
2. **작업의 즐거움**
    * **창작**의 즐거움 : 무엇을 만든다는 순수한 즐거움
    * **유용성**의 즐거움 : 다른 사람에게 쓸모 있는 뭔가를 만드는 데서 오는 즐거움
    * **문제 해결**의 즐거움 : 복잡한 객체를 멋지게 만들어내고 그것이 절묘한 사이클로 작동하며, 개발 시작 시 정한 원칙이 어떤 결과를 낳았는지 지켜보는 즐거움
    * **학습**의 기쁨 : 항상 새로운 무언가를 배운다는 기쁨
    * **매체 이용**의 즐거움 : 다루기 쉬운 매체를 통해 창작에 대한 열망 충족
3. **작업의 고통**
    * **완벽성** 요구 : 문자 하나라도 올바른 형식에 맞지 않으면 작동 X
    * **권한** 부족 : 작업 환경, 목표 설정 등의 권한은 타인에 종속됨 / 타인의 불완전한 프로그램에 의존
    * **버그 수정** : 자잘한 버그 찾기 및 수정은 단순 노동에 불과 / 프로그램의 완성에 다가갈수록 더욱 느려지는 오류 검증
    * **퇴물화** : 겨우 완성한 제품의 아이디어가 쓸모없는 퇴물임이 드러남

## :ticket: Chapter 2. 맨먼스 미신
1. **낙관주의**
    * 모든 임무가 주어진 시간 안에 꼭 완수될 것이라는 잘못된 가정
    * 구현에서의 어려움은 물리적 매체의 한계와 아이디어의 현실 부적합성
    * 다만, 컴퓨터 프로그래밍은 다루기 쉬운 매체를 이용하므로 아이디어의 문제 -> 낙관주의를 정당화하기는 어려움
2. **Man-Month**
    * Man-Month : 견적과 일정에 사용되는 노력의 단위 / 다른 작업의 경우 작업자가 많을수록 일정은 줄어듦
    * 시스템 프로그래밍에서는 **상호 커뮤니케이션**과 **순차적 제한**이 존재하므로 작업자가 늘어도 일정은 그대로
    * 인력이 늘어날수록 **훈련** 및 **커뮤니케이션**의 부담이 기하급수적으로 증가 -> 일정이 오히려 연장되는 상황 초래
3. **시스템 테스트**
    * 저자의 일정 분배 방식 : 33% 계획 / 17% 코딩 / 25% 컴포넌트 및 초기 시스템 테스트 / 25% 시스템 테스트 및 모든 컴포넌트 입수
    * 상세하고 확실한 명세를 만들어내기에는 넉넉하지 않으므로 계획에 할애된 부분을 보통보다 늘림
    * 전체 일정의 **절반**을 **디버깅**에 할애
    * 예측하기 쉬운 코딩 작업은 가장 적게 할애
4. **비겁한 견적**
    * 정량적 방법론이 아닌 직감에 의한 견적은 위험함
    * 버그 발생 수치나 견적 규칙 등의 **생산성 수치**를 개발하고 발표한다면 도움이 됨
5. **되풀이되는 일정 참사**
    * 일정이 늦어진 소프트웨어 프로젝트에 인력을 추가하는 것은 일정을 더욱 늦추는 결과를 낳을 뿐이다.

## :ticket: Chapter 3. 수술 팀
1. **문제 상황**
    * **효율성과 개념적 무결성**을 원한다면 **소수 정예**의 팀으로 설계 및 개발
    * 대형 시스템의 경우 **충분한 인력**을 투입해 **적절한 시기에 제품을 출시**해야 함
    * 둘 사이의 딜레마를 어떻게 조화시켜야 하는가?
2. **밀스의 제안**
    * 대형 작업의 각 부분을 수술 팀처럼 나누어서 처리 (아래는 총 10명으로 구성된 팀의 역할 분배 예시)
    * **외과의사 (프로그래머 장)** : 상당한 수준의 지식 보유자 - 프로그램 설계 / 코드 작성 및 테스트 / 문서 작업
    * **부기장** : 외과의사의 보험과 같은 역할 - 프로그램 설계 시 같이 고민/토론 및 평가
    * **행정관** : 돈과 인력, 공간, 행정조직과의 접촉 등을 전담하는 사람
    * **편집자** : 외과의사가 만든 문서 초안을 비평 및 재작업
    * **비서** : 행정관과 편집자에게 각각 비서 1명 씩은 필요
    * **프로그램 사무원** : 프로그래밍-제품 라이브러리에 있는 팀의 모든 기술적 기록의 관리 책임
    * **도구 대장장이** : 자신 팀의 외과의사가 원하거나 필요한 도구를 확보
    * **검사원** : 시스템의 테스트 케이스 고안 / 디버깅 진행
    * **언어 변호사** : 특정 언어를 사용하는 참신하고 효과적인 방법 발굴
3. **운영 방식**
    * 외과의사와 부기장 모두가 전체 설계와 코드 전체를 모두 알고 있어 공간과 디스크 액세스 할당 등의 노력 절감 가능
    * 수술 팀 방식에서는 수평적보다는 수직적에 가까우므로 이해관계가 충돌할 염려가 적음
    * 구성원들 사이의 커뮤니케이션의 극단적인 단순화

## :ticket: Chapter 4. 귀족정치, 민주주의 그리고 시스템 설계
1. **개념적 무결성**
    * 시스템이 하나의 목표를 따르며, **일관된 설계**를 바탕으로 제작되는 것
    * 시스템 프로그래밍의 목적은 컴퓨터를 좀 더 **쉽게** 사용하려는 것 - **기능 vs 개념적 복잡함**의 비율은 시스템 설계 점검에 최적의 척도
    * 기능이 주어지면 그것을 가장 단순하고 직설적으로 명세할 수 있는 시스템이 최고
    * 사용의 쉬움 = 설계 및 개념의 무결성
2. **귀족정치와 민주주의**
    * 개념적 무결성 vs 일정 압박 - **시스템 설계 인원 수**의 딜레마 발생
    * 첫 번째 해결법 : 설계자와 실제 프로그래머들의 작업을 조심스럽게 **분할**
        * **설계**는 어떤 일이 일어나는지 설명 / **구현**은 그 일이 일어나게 하려면 어떻게 되어야 하는지 설명
        * Ex) 시계 설계는 문자판, 시침, 태엽 감개 등의 구조 / 시계 구현은 시계의 동력 공급이나 정확성 제어 등의 메커니즘에 대한 설명
        * 일부 설계자들만의 **귀족정치** vs 모두에게 아이디어를 모으는 **민주주의**
            * 설계의 경우 시스템의 개념적 무결성을 높이기 위해 전자를 선호
            * 구현의 경우 다양한 아이디어, 기술적 탁월성 등이 필요하므로 후자를 선호 
    * 두 번째 해결법 : 프로그래밍 구현 팀을 새롭게 구성
3. **구현자들은 기다리는 동안 무엇을 하나?**
    * 전체적인 작업은 아키텍처, 구현, 실현 세 가지 단계가 존재 - 모두 병렬적으로 진행 가능
    * 명확한 시스템 개요, 비용, 성능 목표 정도만 있어도 작업 시작 가능
    * 서브루틴 규칙, 감독 기법, 검색 및 정렬 알고리즘 결정
  
## :ticket: Chapter 16. 은 총알은 없다
1. **은 총알**
    * 늑대인간을 마법처럼 잠재울 수 있는 '은 총알' 비유
    * 소프트웨어 개발에서 근본적인 문제를 해결해 줄 수 있는 '은 총알'은 존재하지 않음
2. **본질적 어려움**
    * **복잡성** : 소프트웨어 본체들은 서로 같은 부분이 없어 어떤 것보다 복잡함 / 기능의 복잡성 + 구조의 복잡성
    * **순응성** : 다른 기존 인터페이스들 사이에서 순응해야 하기 때문에 생기는 문제
    * **변경 가능성** : 소프트웨어는 다른 것들에 비해 변경하기 수월하다는 점이 오히려 문제가 됨 / 기존 기능의 확장 + 새로운 기기에 순응하기 위해 잦은 변경 필요
    * **비가시성** : 기하학적 추상화가 어려움
3. **부차적 어려움을 해결한 과거의 큰 발전**
    * **고수준 언어** : 프로그램의 부차적 어려움이였던 개념적 구성 (연산, 데이터 타입 등) 해결 / 다만 어느 수준을 넘어서면 사용자들의 부담을 오히려 늘림
    * **시분할** : CPU와 같은 중앙 자원을 여러 사용자가 동시에 나누어 사용 / 반응시간이 인간의 지각 한계를 넘어서면 큰 이점 기대 불가
    * **통합 프로그래밍 환경** : 표준 형식으로 개발된 여러 프로그램을 함께 사용 가능하게 함
4. **은 총알에 가장 가깝게 접근했던 기술**
    * **에이다와 기타 고수준 언어의 발전** : 에이다(Ada)는 언어에 대한 새로운 진보적인 철학을 담았지만 그 또한 하나의 고수준 언어에 지나지 않음
    * **객체 지향 프로그래밍** : 추상적 타입 / 계층적 타입 개념으로 한 수준 높은 설계를 표현할 수 있지만, 본질적 어려움을 제거할 수는 없음
    * **인공 지능** : 대다수의 AI 작업은 특정 문제에만 통하고 다른 곳에 적용하려면 어느 정도의 추상과 창조성이 필요
    * **전문가 시스템** : 일반화한 추론 엔진과 규칙 기반을 가진 프로그램 / 최고 프로그래머들의 축적된 경험과 지혜를 신입 프로그래머의 서비스에 담아낼 수 있게 도와줌
    * **자동 프로그래밍** : 문제 명세서만 가지고 문제 해결 프로그램을 만들어내는 것 / 다만 일반적인 소프트웨어 시스템 영역에서는 적용하기 힘듦
    * **그래픽 프로그래밍** : 컴퓨터 그래픽을 소프트웨어 설계에 적용 / 아직은 납득할 수준의 결과조차 없음
    * **프로그램 검증** : 강력한 개념이지만, 그렇다고 검증을 한다고 해서 오류 없는 프로그램이 만들어지는 것도 아님
    * **환경과 도구** : 가치는 있지만 한계가 명확
    * **워크스테이션** : 환영할만한 일이지만 마법같은 발전은 기대 불가
5. **개념적 본질에 대한 전망 밝은 도전**
    * **구매 vs 구축** : 소프트웨어를 구축하지 말고 그냥 시중의 소프트웨어를 구매하는 것 / 가장 급진적인 해법
    * **요구사항 다듬기와 빠른 시제품 작업**
    * **점증적 개발** : 소프트웨어의 구축이 아닌 **성장**
    * **대단한 설계사들** : 말 그대로 최고의 설계사를 키우는 방법 개발
